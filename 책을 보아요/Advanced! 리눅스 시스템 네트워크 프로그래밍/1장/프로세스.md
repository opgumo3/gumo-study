# 프로세스
## fork/exec
- `fork` 는 **프로세스를 복제**하는 방법으로 본 프로세스를 부모 프로세스, 복제된 프로세스는 자식 프로세스 하고 함.

## 프로세스 복제
- 프로세스를 복제하여 멀티태스킹을 할 수 있음.
    - 각 프로세스는 독립적으로 작동하여 여러 CPU 를 장비하고 있다면 성능이 향상될 수 있음.
- 하지만 프로세스간 데이터를 주고받거나 데이터 통신 처리의 비용이 큰 경우 성능 하락이 생길 수 있음.
- 만약 복제된 프로세스들이 공통으로 사용하는 파일이나 I/O 는 `mmap`을 이용해 비용을 최소화하는 것을 고려할 수 있음.

```
🤖 mmap
- 파일을 메모리에 매핑하여, 파일 내용을 메모리처럼 다룰 수 있게 하는 기술.
- 파일에 동시에 write 하는 경우에는 충돌 위험이 있어 "파일 락" 이나 "세마포어/뮤텍스" 등 동기화 도구를 사용할 수 있음.
- 플랫폼에 종속적임.

🤖 IPC (Inter Process Communication)
- 서로 다른 프로세스간 데이터를 주고받기 위해 사용하는 기술.
- 운영체제에서 각 프로세스는 기본적으로 서로의 메모리에 접근할 수 없으나 공유해야하는 경우 IPC 방법을 사용함.
- 예시) 파이프, Named Pipe, 메시지 큐, 공유 메모리, 소켓, 시그널, 세마포어/뮤텍스
```

## fork-exec 예시
- `ls` 명령을 실행할 떄, shell 은 fork 를 하여 프로세스를 복제하고, 곧바로 exec 을 호출하여 /bin/ls 프로그램 이미지로 교체함.
- 연달아서 fork-exec 호출하는 방식으로 ineted 형식의 프로그램도 있음.

```
🤖 ls 명령어 실행 흐름
- shell 이 명령을 파싱하고 실행 파일을 찾음. (see also "which [program]")
- shell 은 fork() 로 자식 프로세스 생성
- 자식 프로세스에서 exec() 호출하여 /bin/ls 실행파일로 덮어씀.
- ls 실행이 끝나면 exit() 호출하여 자식 프로세스는 종료.
- 부모 프로세스(shell) 은 wait() 로 자식 프로세스의 끝을 기다리고 프롬프트로 복귀
```

```c
pid_t pid = fork();
if (pid == 0) {
    execvp("ls", ["ls", "-al", NULL]);
}
```

```
🤖 시스템 콜 (syscall)
- 사용자 프로그램(유저 모드)이 운영 체제(커널 모드) 에게 어떤 서비스를 요청할 때 사용하는 인터페이스
- 예시) open(), read(), fork()
```

```
🤖 ineted 형식의 프로그램
- 네트워크에 대한 복잡한 부분을 직접 처리하는 댇신, stdin 과 stdout 을 통해 통신하도록 만들어진 프로그램.
- inetd 나 xinetd 와 같은 슈퍼 데몬에 의해 실행되는 것을 전제로 함.
- 요청을 감지하고 fork() 로 자식 프로세스를 생성
- 감지한 네트워크 소켓을 자식에 연결하고 exec() 를 통해 해당 서비스의 실제 프로그램을 실행.
```

## fork-exec 을 더 간단하게
- `popen` 
    - 부모 자식 프로세스 간 주고받을 데이터가 있을 때 파이프를 이용해 통신할 수 있는 기능 있음.
- `system`
    - 간단히 프로그램을 실행할 떄 사용.


# posix_spawn
- IEEE 1003.1d-1999 에서 fork-exec 을 대체할 수 있는 기능으로서 `posix_spawn` 계열의 새로운 프로세스 실행 방법이 제안됨.

## 대체해야하는 이유
- 원래 fork 는 부모 프로세스를 복제할 때 부모의 정적 정보를 복제함.
    - 힙 메모리, 정적 메모리, IPC 자원, 열린 파일, 시그널 마스크
- fork 후 곧바로 exec 을 한다면 위 정보를 쓰지 않는 경우가 많고, 이것은 쓰지도 않는 자원을 복제하는 오버헤드가 존재한다는 것을 의미함.
- posix_spawn 은 **부모 프로세스의 자원 6가지(열린 파일, 프로세스 그룹 ID, 유저 및 그룹 ID, 시그널 마스크, 스케줄링)의 자원을 선택적으로 복제**할 수 있도록 디자인 됨.

# fork()
```c
pid_t fork(void)
```
- 호출에 성공하면 프로세스가 복제되고 정수의 pid_t 타입을 반환함.
- 리턴값은 3가지의 종류가 있고, 각 값에 따라 다르게 처리하도록 함.

```c
switch ( (ret = fork())) {
    case 0: /* 0: 자식 프로세스에게 리턴되는 값으로, 아래 블록은 자식 프로세스인 경우에 실행 */
        do_child();
        break;
    case -1: /* 에러 */
        do_error_handle();
        break;
    default: /* 부모 프로세스에게는 양수의 값이 리턴되고, 자식 프로세스의 PID 를 의미.*/
        do_parent();
        break;
}
```

## vfork 와 성능 문제
### fork-exec 의 문제점
- 사용하지 않는 자원의 복제로 인한 오버헤드 존해
    복제(fork) 된 후에 exec 계열 함수를 호출하는 순간 복제한 페이지 테이블이 모두 해제됨.
- 페이지 테이블을 복제하지 않는 vfork 가 제안되어 사용되었지만, 이후에 fork 에 copy-on-write 가 도입되어 성능적인 차이가 없어짐.

```
🤖 페이지 테이블
가상 메모리를 실제 물리 메모리에 매핑하기 위해 사용하는 자료 구조.
논리 주소 공간 <-> 물리 주소 공간
```

# exec(3) 계열 함수
```
🤖 exec(3) ?
- 괄호 안의 숫자는 man 페이지의 섹션 번호.
    - manual 은 일반적으로 8개의 섹션으로 나눠지고, 페이지는 전통적으로 [name(section)] 표기법을 사용함.
    - 예시. printf(3) = man 3 printf
- 즉 exec(3) 는 man 페이지 섹션 3의 exec 함수 설명
- 아래는 일반적인 섹션 변호 별 설명
    - 1 : 사용자 명령어
    - 2 : 시스템 콜
    - 3 : 라이브러리 함수
    - 4 : 특수 파일(장치 파일 등)
    - 5 : 파일 형식과 규약
    - 6 : 게임이나 화면 보호기
    - 7 : 기타
    - 8 : 시스템 관리자/데몬용 명령어
```

- exec 계열 함수는 현재 실행 중인 프로세스의 이미지를 새로운 프로세스 이미지로 대체함.
    - 프로세스 이미지가 대체되면 프로세스의 실행 코드는 교체되지만 기본적인 PID, PPID, 파일 기술자 등의 프로세스 정보는 유지됨.
- exec 계열 함수의 첫 번째 인자는 경로(절대/상대) 혹은 파일명을 넣을 수 있는데, 파일명을 넣는 경우 현재 작업 디렉토리에서 찾을 수도 있고 `PATH` 환경 변수에 등록된 디렉토리에서 찾을 수도 있음.
    - 인자의 이름이 `path` 라면 현재 작업 디렉토리, `file` 라면 PATH 를 검색.

```c
#include <unistd.h>
#include <stdio.h>

int main() 
{
    if (execl("/bin/ls", "ls", "-l", NULL) == -1) {
        perror("execl failed");
    }
    printf("This line will not be executed.\n"); // 프로세스 이미지가 변경되어 출력되지 않음.
    return 0;
}
```

## 상속되지 않는 파일 기술자
- 기본적으로 exec 는 부모의 파일 기술자를 복제하지만, fork 를 하기전에 특정 파일 기술자에 fcntl 로 FD_CLOEXEC 플래그를 지정하면 해당 파일 기술자는 exec 실행될 때 닫히게됨.

```
🤖 파일 기술자(파일 디스크립터. FD)
리눅스/유닉스에서 자원(열린 파일, 소켓, 파이프, 터미널 등)을 가리키는 정수 값

🤖 fcntl()
파일 디스크립터의 속성을 설정하거나 조회할 수 있는 함수

🤖 FD_CLOEXEC
- 파일 디스크립터에 이 플래그를 설정하면, 이후에 exec()가 호출될 때 그 디스크립터는 자동으로 닫힘.
- 보안 또는 자원 누수 방지에 유용함
```