#### 요약

#### 추가 학습
- EntityManager, @PersistenceContext
- 하나의 애그리거트에서 여러 저장소를 사용할 수 있지 않는가?
    - 🤖 A: 애그리거트는 하나의 트랜잭션 안에서 일관성을 유지하는 경계. 위 케이스는 보통 애그리거트 경계를 잘못 설정했을 때 발생.
- 애그리거트 클래스와 JPA Entity 분리가 필요하지 않을까?
    - 🤖 A: JPA Entity는 Persistence Model이고, Aggregate는 Domain Model 로 분리 필요함.
- `@Embeddable`, `@Embedded`, `@AttributeOverrides`, `@AttributeOverride`
    - 🤖 A:
        - `@Embeddable`: 값 객체(Value Object)를 정의할 때 사용. 별도의 테이블을 갖지 않음.
        - `@Embedded`: 엔티티 내부에서 @Embeddable 클래스를 포함시키는 어노테이션.
        - `@AttributesOverride`: 값 객체를 엔티티에서 여러 번 사용할 때 사용.
        - `@AttributeOverride`: 임베디드 타입(Embeddable)의 특정 필드가 매핑되는 컬럼 정보를 재정의
- `@OneToMany` vs `@ElementCollection`, `@CollectionTable`
    - 🤖 A: @OneToMany 는 “엔티티의 연관관계”, @ElementCollection 은 엔티티가 아닌 값 객체의 모음
- 주문 도메인의 애그리거트 루트인 Order 에서 MemberId(Orderer) 클래스는 어디에 정의되어야 하는지?


# 애그리거트와 JPA 매핑
- 애그리거트는 `@Entity` 로, 밸류는 `@Embeddable`, 밸류 프로퍼티는 `@Embedded` 로 매핑.
- `@Entity`, `@Embeddable` 로 클래스를 매핑하면, DB 데이터를 매핑된 객체로 생성하기 위해 기본 생성자가 필요함.
    - 불변 객체로 기본 생성자가 필요하지 않음에도 JPA 프로바이더에서 사용하기 위해 필요하므로, 다른 코드에서 기본 생성자를 사용할 수 없도록 `protected` 로 선언.

# 필드 접근 방식
- JPA 는 필드와 메서드 방식으로 매핑을 처리할 수 있음.
    - 메서드 방식 : 엔티티에 `@Access(AccessType.PROPERTY)` 를 붙이고 프로퍼티를 위한 get/set 메소드를 구현
    - 필드 방식 : 프로퍼티를 위한 공개 get/set 메소드는 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아짐.
        - 매핑 방식을 필드 방식으로 선택(`@Access(AccessType.FIELD)`) 하여 불필요한 get/set 메소드를 구현하지 않도록 한다.
        - 특히 set 메소드 대신 의도가 잘 드러나는 기능을 제공해야함. / 주문의 상태를 취소로 변경하는 기능을 setState() 가 아닌 cancel() 메소드로 제공.

# AttributeConverter 로 밸류 매핑 처리
- 두 개 이상의 프로퍼티를 가진 밸류를 하나의 컬럼에 매핑하는 경우에 사용할 수 있음.
    - 예. Length 밸류 - value, unit 프로퍼티 = width 컬럼

# 밸류 컬렉션
- 밸류 컬렉션을 다른 테이블로 매핑할 때, `@ElementCollection`, `@CollectionTable` 을 함께 사용.
- 이 클래스는 @Embeddable 형태의 값 객체여야 함.
- `@OrderColumn` 으로 컬렉션의 인덱스를 지정할 수 있음.

# 밸류를 이용한 ID 매핑
- JPA 의 식별자 규칙으로, 식별자로 사용할 밸류는 Serializable 인터페이스를 상속해야함.
- 사용할 때는 `@Id` 대신 `@EmbeddedId` 사용.
- 밸류로 식별자를 구현하여 식별자에 기능을 추가할 수 있음.